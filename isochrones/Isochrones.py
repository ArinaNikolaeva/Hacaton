# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Isochrones
                                 A QGIS plugin
 Isochrones
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-12-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Isochrones
        email                : Isochrones
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import heapq
import math
import os.path
import re
from collections import defaultdict
from dataclasses import dataclass
from typing import Dict, List, Optional, Sequence, Tuple

from qgis.PyQt.QtCore import QCoreApplication, QSettings, QTranslator, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from qgis.core import (
    Qgis,
    QgsCoordinateTransform,
    QgsCsException,
    QgsFeature,
    QgsFeatureRequest,
    QgsCategorizedSymbolRenderer,
    QgsField,
    QgsFields,
    QgsFillSymbol,
    QgsGeometry,
    QgsMessageLog,
    QgsMapLayer,
    QgsPointXY,
    QgsProject,
    QgsRasterLayer,
    QgsRendererCategory,
    QgsSpatialIndex,
    QgsVectorLayer,
    QgsWkbTypes,
)

from .resources import *
from .Isochrones_dialog import IsochronesDialog


class IsochroneError(Exception):
    pass


@dataclass
class IsochroneParameters:
    stop_layer: QgsVectorLayer
    stop_id_field: str
    outbound_ids: List[str]
    return_ids: List[str]
    network_layer: QgsVectorLayer
    height_layer: Optional[QgsMapLayer]
    population_layer: QgsVectorLayer
    population_field: str
    limit_meters: float
    speed_kmh: float
    height_step: float
    height_penalty: float
    continuous_penalty: bool
    manual_penalty: float
    use_selection: bool
    add_to_project: bool
    corridor_width: float
    transport_type: str
    time_intervals: List[int]
    use_uds_speeds: bool
    start_point_id: Optional[str] = None
    uds_speed_field: Optional[str] = None


class Isochrones:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Isochrones_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Isochrones')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Isochrones', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Isochrones/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Построить'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Isochrones'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        if self.first_start == True:
            self.first_start = False
            self.dlg = IsochronesDialog()

        self.dlg.show()
        result = self.dlg.exec_()
        
        if result:
            try:
                params = self._collect_parameters()
                
                current_tab = self.dlg.tabWidget.currentIndex()
                if current_tab == 0:
                    processor = PedestrianIsochroneProcessor(self.iface, params)
                else:
                    processor = MultiIntervalIsochroneProcessor(self.iface, params)
                
                summary = processor.run()
                if summary:
                    self.iface.messageBar().pushInfo(self.tr('Isochrones'), summary)
                    
            except IsochroneError as exc:
                self.iface.messageBar().pushCritical(self.tr('Isochrones'), str(exc))
            except Exception as exc:
                self.iface.messageBar().pushCritical(
                    self.tr('Isochrones'),
                    self.tr('Не удалось построить изохроны: {}').format(exc))

    def _collect_parameters(self) -> IsochroneParameters:
        current_tab = self.dlg.tabWidget.currentIndex()
        
        if current_tab == 0:  # Задача 1
            return self._collect_parameters_task1()
        else:  # Задача 2
            return self._collect_parameters_task2()

    def _collect_parameters_task1(self) -> IsochroneParameters:
        stop_layer = self.dlg.stopLayerCombo.currentLayer()
        stop_id_field = self.dlg.stopFieldCombo.currentText()
        outbound_ids = self._parse_id_list(self.dlg.outboundIdsEdit.toPlainText())
        return_ids = self._parse_id_list(self.dlg.returnIdsEdit.toPlainText())
        network_layer = self.dlg.networkCombo.currentLayer()
        height_layer = self.dlg.heightCombo.currentLayer()
        population_layer = self.dlg.populationCombo.currentLayer()
        population_field = self.dlg.populationFieldCombo.currentText()
        limit_value = self.dlg.limitSpin.value()
        speed_kmh = self.dlg.speedSpinTask1.value()
        limit_mode_idx = self.dlg.limitModeCombo.currentIndex()

        for layer, label in (
            (stop_layer, self.tr('слой остановок')),
            (network_layer, self.tr('слой графа УДС')),
            (population_layer, self.tr('слой населения')),
        ):
            if layer is None:
                raise IsochroneError(self.tr('Не выбран {}.').format(label))

        if not stop_id_field:
            raise IsochroneError(self.tr('Выберите поле ID остановок.'))
        if not outbound_ids:
            raise IsochroneError(self.tr('Заполните список ID для выезда.'))
        if not return_ids:
            raise IsochroneError(self.tr('Заполните список ID для возврата.'))

        if network_layer.geometryType() != QgsWkbTypes.LineGeometry:
            raise IsochroneError(self.tr('Слой графа должен быть линейным.'))

        if not population_field:
            raise IsochroneError(self.tr('Выберите поле населения.'))

        if limit_value <= 0:
            raise IsochroneError(self.tr('Порог доступности должен быть больше нуля.'))
        if speed_kmh <= 0:
            raise IsochroneError(self.tr('Скорость должна быть больше нуля.'))

        if limit_mode_idx == 0:
            limit_meters = limit_value
        else:
            limit_meters = (limit_value * speed_kmh * 1000.0) / 60.0

        corridor_width = max(3.0, min(15.0, limit_meters * 0.02))

        if height_layer and not isinstance(height_layer, QgsRasterLayer):
            self.iface.messageBar().pushWarning(
                self.tr('Isochrones'),
                self.tr('Высоты поддерживаются только для растровых слоёв. Слой будет проигнорирован.'))
            height_layer = None

        return IsochroneParameters(
            stop_layer=stop_layer,
            stop_id_field=stop_id_field,
            outbound_ids=outbound_ids,
            return_ids=return_ids,
            network_layer=network_layer,
            height_layer=height_layer,
            population_layer=population_layer,
            population_field=population_field,
            limit_meters=limit_meters,
            speed_kmh=speed_kmh,
            height_step=self.dlg.heightStepSpin.value(),
            height_penalty=self.dlg.heightPenaltySpin.value(),
            continuous_penalty=self.dlg.continuousPenaltyCheck.isChecked(),
            manual_penalty=self.dlg.manualPenaltySpin.value(),
            use_selection=self.dlg.useSelectionCheck.isChecked(),
            add_to_project=self.dlg.addLayersCheck.isChecked(),
            corridor_width=corridor_width,
            transport_type="Пешком",
            time_intervals=[],
            use_uds_speeds=False,
            start_point_id=None,
            uds_speed_field=None,
        )

    def _collect_parameters_task2(self) -> IsochroneParameters:
        stop_layer = self.dlg.startPointLayerCombo.currentLayer()
        stop_id_field = self.dlg.startPointFieldCombo.currentText()
        start_point_id = self.dlg.startPointIdEdit.text().strip()
        network_layer = self.dlg.networkComboTask2.currentLayer()
        height_layer = self.dlg.heightComboTask2.currentLayer()
        population_layer = self.dlg.populationComboTask2.currentLayer()
        population_field = self.dlg.populationFieldComboTask2.currentText()
        transport_type = self.dlg.transportCombo.currentText()
        use_uds_speeds = self.dlg.useUdsSpeedsCheck.isChecked()
        uds_speed_field = self.dlg.udsSpeedFieldCombo.currentText() if use_uds_speeds else None
        speed_kmh = self.dlg.speedSpinTask2.value()

        for layer, label in (
            (stop_layer, self.tr('слой точек начала')),
            (network_layer, self.tr('слой графа УДС')),
            (population_layer, self.tr('слой населения')),
        ):
            if layer is None:
                raise IsochroneError(self.tr('Не выбран {}.').format(label))

        if not stop_id_field:
            raise IsochroneError(self.tr('Выберите поле ID точек.'))
        if not start_point_id:
            raise IsochroneError(self.tr('Введите ID точки начала.'))

        if network_layer.geometryType() != QgsWkbTypes.LineGeometry:
            raise IsochroneError(self.tr('Слой графа должен быть линейным.'))

        if not population_field:
            raise IsochroneError(self.tr('Выберите поле населения.'))

        if speed_kmh <= 0:
            raise IsochroneError(self.tr('Скорость должна быть больше нуля.'))

        time_intervals = []
        if self.dlg.time5Check.isChecked():
            time_intervals.append(5)
        if self.dlg.time10Check.isChecked():
            time_intervals.append(10)
        if self.dlg.time15Check.isChecked():
            time_intervals.append(15)
        if self.dlg.time20Check.isChecked():
            time_intervals.append(20)
        if self.dlg.time30Check.isChecked():
            time_intervals.append(30)
        if self.dlg.timeCustomCheck.isChecked():
            time_intervals.append(self.dlg.timeCustomSpin.value())

        if not time_intervals:
            raise IsochroneError(self.tr('Выберите хотя бы один временной интервал.'))

        if height_layer and not isinstance(height_layer, QgsRasterLayer):
            self.iface.messageBar().pushWarning(
                self.tr('Isochrones'),
                self.tr('Высоты поддерживаются только для растровых слоёв. Слой будет проигнорирован.'))
            height_layer = None

        limit_meters = max((max(time_intervals) * speed_kmh * 1000.0) / 60.0, 500.0)
        corridor_width = max(3.0, min(15.0, limit_meters * 0.02))

        return IsochroneParameters(
            stop_layer=stop_layer,
            stop_id_field=stop_id_field,
            outbound_ids=[start_point_id],
            return_ids=[start_point_id],
            network_layer=network_layer,
            height_layer=height_layer,
            population_layer=population_layer,
            population_field=population_field,
            limit_meters=limit_meters,
            speed_kmh=speed_kmh,
            height_step=self.dlg.heightStepSpinTask2.value(),
            height_penalty=self.dlg.heightPenaltySpinTask2.value(),
            continuous_penalty=self.dlg.continuousPenaltyCheckTask2.isChecked(),
            manual_penalty=0.0,
            use_selection=False,
            add_to_project=self.dlg.addLayersCheckTask2.isChecked(),
            corridor_width=corridor_width,
            transport_type=transport_type,
            time_intervals=time_intervals,
            use_uds_speeds=use_uds_speeds,
            start_point_id=start_point_id,
            uds_speed_field=uds_speed_field,
        )

    def _parse_id_list(self, text: str) -> List[str]:
        if not text:
            return []
        parts = re.split(r'[,\s;]+', text)
        return [part.strip() for part in parts if part.strip()]


class PedestrianIsochroneProcessor:
    """Compute two pedestrian isochrone sets and their overlap."""

    SNAP_TOLERANCE = 35.0  # meters

    def __init__(self, iface, params: IsochroneParameters):
        self.iface = iface
        self.params = params
        self.project = QgsProject.instance()
        self.network_crs = params.network_layer.crs()
        self._transform_cache: Dict[str, Optional[QgsCoordinateTransform]] = {}
        self.graph: Optional[Graph] = None
        self._tolerance_warning_shown = False

    def tr(self, text: str) -> str:
        return QCoreApplication.translate('Isochrones', text)

    def run(self) -> str:
        builder = GraphBuilder(self.params)
        self.graph = builder.build()

        outbound_sources = self._snap_stop_nodes(self.params.outbound_ids)
        return_sources = self._snap_stop_nodes(self.params.return_ids)

        outbound_dist = self._dijkstra(outbound_sources)
        return_dist = self._dijkstra(return_sources)

        outbound_zone = self._build_zone(outbound_dist)
        return_zone = self._build_zone(return_dist)

        if not outbound_zone or outbound_zone.isEmpty():
            raise IsochroneError(self.tr('Не удалось построить зону выезда.'))
        if not return_zone or return_zone.isEmpty():
            raise IsochroneError(self.tr('Не удалось построить зону возврата.'))

        zone_geometries = self._resolve_zone_geometries(outbound_zone, return_zone)
        stats = self._population_stats(zone_geometries)
        layer = self._create_result_layer(zone_geometries, stats)
        summary = self._build_summary(stats)
        if layer:
            layer.setAbstract(summary)
            layer.setCustomProperty('Isochrones/summary', summary)
        QgsMessageLog.logMessage(summary, 'Isochrones', Qgis.Info)
        if self.params.add_to_project and layer:
            QgsProject.instance().addMapLayer(layer)
        return summary

    def _build_summary(self, stats: List[Dict[str, float]]) -> str:
        names = [
            self.tr('Выезд (только)'),
            self.tr('Возврат (только)'),
            self.tr('Обе стороны'),
        ]
        parts = []
        for name, data in zip(names, stats):
            population = data.get('population', 0.0)
            share = data.get('share', 0.0)
            parts.append(f'{name}: {population:.0f} чел.')
        return ', '.join(parts)

    def _snap_stop_nodes(self, stop_ids: Sequence[str]) -> List[int]:
        points = self._collect_stop_points(stop_ids)
        node_ids: List[int] = []
        for point in points:
            node_id, distance = self.graph.nearest_node(point)
            if node_id is None:
                raise IsochroneError(self.tr('Не найден узел графа для точки остановки.'))
            if distance > self.SNAP_TOLERANCE:
                if not self._tolerance_warning_shown:
                    self.iface.messageBar().pushWarning(
                        self.tr('Isochrones'),
                        self.tr('Остановки находятся далее {} м от сети. Используем ближайшие узлы.').format(
                            self.SNAP_TOLERANCE))
                    self._tolerance_warning_shown = True
            node_ids.append(node_id)
        if not node_ids:
            raise IsochroneError(self.tr('Не выбрано ни одной остановки.'))
        return node_ids

    def _collect_stop_points(self, stop_ids: Sequence[str]) -> List[QgsPointXY]:
        if not stop_ids:
            raise IsochroneError(self.tr('Укажите хотя бы один ID остановки.'))
        layer = self.params.stop_layer
        field_name = self.params.stop_id_field
        field_idx = layer.fields().indexOf(field_name)
        if field_idx == -1:
            raise IsochroneError(self.tr('Поле {} не найдено в слое остановок.').format(field_name))
        transform = self._transform_for_layer(layer)
        target_ids = [self._normalize_id(value) for value in stop_ids]
        remaining = set(target_ids)
        points: List[QgsPointXY] = []
        features = (
            layer.getSelectedFeatures()
            if self.params.use_selection and layer.selectedFeatureCount() > 0
            else layer.getFeatures()
        )
        for feature in features:
            attr_value = self._normalize_id(feature[field_idx])
            if attr_value not in remaining:
                continue
            geom = feature.geometry()
            if not geom or geom.isEmpty():
                continue
            if transform:
                try:
                    geom.transform(transform)
                except QgsCsException as exc:
                    raise IsochroneError(self.tr('Ошибка трансформации геометрии остановок: {}').format(exc)) from exc
            point = self._point_from_geometry(geom)
            if point:
                points.append(point)
                remaining.discard(attr_value)
            if not remaining:
                break
        if remaining:
            raise IsochroneError(
                self.tr('ID остановок не найдены: {}').format(', '.join(sorted(remaining))))
        return points

    def _collect_points(self, layer: QgsVectorLayer) -> List[QgsPointXY]:
        transform = self._transform_for_layer(layer)
        points: List[QgsPointXY] = []
        features = (
            layer.getSelectedFeatures()
            if self.params.use_selection and layer.selectedFeatureCount() > 0
            else layer.getFeatures()
        )
        for feature in features:
            geom = feature.geometry()
            if not geom or geom.isEmpty():
                continue
            if transform:
                try:
                    geom.transform(transform)
                except QgsCsException as exc:
                    raise IsochroneError(self.tr('Ошибка трансформации геометрии: {}').format(exc)) from exc
            point = self._point_from_geometry(geom)
            if point:
                points.append(point)
        if not points:
            raise IsochroneError(self.tr('Не удалось прочитать точки слоя {}.').format(layer.name()))
        return points

    def _point_from_geometry(self, geom: QgsGeometry) -> Optional[QgsPointXY]:
        geom_type = geom.type()
        if geom_type == QgsWkbTypes.PointGeometry:
            if geom.isMultipart():
                points = geom.asMultiPoint()
                return QgsPointXY(points[0]) if points else None
            return QgsPointXY(geom.asPoint())
        # Фолбэк: берём центроиды для полигонов/линий
        centroid = geom.centroid()
        if centroid and not centroid.isEmpty():
            return QgsPointXY(centroid.asPoint())
        return None

    def _normalize_id(self, value) -> Optional[str]:
        if value is None:
            return None
        return str(value).strip()

    def _transform_for_layer(self, layer: QgsVectorLayer) -> Optional[QgsCoordinateTransform]:
        if layer.crs() == self.network_crs:
            return None
        key = layer.id()
        if key not in self._transform_cache:
            self._transform_cache[key] = QgsCoordinateTransform(layer.crs(), self.network_crs, self.project)
        return self._transform_cache[key]

    def _dijkstra(self, source_nodes: Sequence[int]) -> Dict[int, float]:
        limit = self.params.limit_meters
        dist: Dict[int, float] = {}
        queue: List[Tuple[float, int]] = []
        for node in source_nodes:
            dist[node] = 0.0
            heapq.heappush(queue, (0.0, node))
        while queue:
            cost, node = heapq.heappop(queue)
            if cost > limit:
                continue
            if cost > dist.get(node, math.inf):
                continue
            for edge in self.graph.adjacency.get(node, []):
                next_cost = cost + edge.segment.total_cost()
                if next_cost > limit:
                    continue
                if next_cost + 1e-6 < dist.get(edge.target, math.inf):
                    dist[edge.target] = next_cost
                    heapq.heappush(queue, (next_cost, edge.target))
        return dist

    def _build_zone(self, distances: Dict[int, float]) -> Optional[QgsGeometry]:
        if not distances:
            return None
        limit = self.params.limit_meters
        line_geoms: List[QgsGeometry] = []
        for segment in self.graph.segments:
            if segment.start in distances:
                geom = self._segment_coverage(segment, True, distances[segment.start], limit)
                if geom:
                    line_geoms.append(geom)
            if segment.end in distances:
                geom = self._segment_coverage(segment, False, distances[segment.end], limit)
                if geom:
                    line_geoms.append(geom)

        corridor = self.params.corridor_width
        line_buffers = [
            geom.buffer(corridor, 3)
            for geom in line_geoms
            if geom and not geom.isEmpty()
        ]
        node_buffers: List[QgsGeometry] = []
        max_radius = corridor
        for node_id, cost in distances.items():
            remaining = limit - cost
            if remaining <= 0:
                continue
            radius = min(max_radius, remaining)
            if radius <= 0:
                continue
            point = QgsGeometry.fromPointXY(self.graph.nodes[node_id])
            node_buffers.append(point.buffer(radius, 6))

        candidates = [geom for geom in line_buffers + node_buffers if geom and not geom.isEmpty()]
        if not candidates:
            return None
        zone = QgsGeometry.unaryUnion(candidates)
        if zone and zone.type() != QgsWkbTypes.PolygonGeometry:
            zone = zone.buffer(self.params.corridor_width, 4)
        if zone:
            zone = zone.makeValid()
            try:
                hull = zone.concaveHull(0.4, False)
                if hull and not hull.isEmpty():
                    zone = hull.makeValid()
            except AttributeError:
                pass
        return zone

    def _segment_coverage(
        self,
        segment: 'GraphSegment',
        forward: bool,
        start_cost: float,
        limit: float,
    ) -> Optional[QgsGeometry]:
        remaining = limit - start_cost
        if remaining <= 0 or segment.cost_per_meter <= 0:
            return None
        max_length = min(segment.length, remaining / segment.cost_per_meter)
        if max_length <= 0:
            return None
        geom = segment.geom_forward if forward else segment.geom_backward
        if max_length >= segment.length - 0.01:
            return geom
        try:
            return geom.curveSubstring(0, max_length)
        except AttributeError:
            return geom

    def _resolve_zone_geometries(
        self,
        outbound_zone: QgsGeometry,
        return_zone: QgsGeometry,
    ) -> List[Optional[QgsGeometry]]:
        outbound_zone = self._clean_polygon(outbound_zone)
        return_zone = self._clean_polygon(return_zone)

        both = None
        if outbound_zone and return_zone:
            try:
                both = outbound_zone.intersection(return_zone)
            except Exception:
                both = None
            both = self._clean_polygon(both)

        outbound_only = outbound_zone
        if outbound_zone and both:
            try:
                outbound_only = outbound_zone.difference(both)
            except Exception:
                outbound_only = outbound_zone
        outbound_only = self._clean_polygon(outbound_only)

        return_only = return_zone
        if return_zone and both:
            try:
                return_only = return_zone.difference(both)
            except Exception:
                return_only = return_zone
        return_only = self._clean_polygon(return_only)

        return [outbound_only, return_only, both]

    def _clean_polygon(self, geom: Optional[QgsGeometry]) -> Optional[QgsGeometry]:
        if not geom or geom.isEmpty():
            return None
        geom = geom.makeValid()
        if not geom or geom.isEmpty():
            return None
        if geom.type() != QgsWkbTypes.PolygonGeometry:
            geom = geom.buffer(0, 0)
        if geom and geom.isEmpty():
            return None
        return geom

    def _population_stats(self, polygons: List[Optional[QgsGeometry]]) -> List[Dict[str, float]]:
        field_name = self.params.population_field
        field_idx = self.params.population_layer.fields().indexOf(field_name)
        if field_idx == -1:
            raise IsochroneError(self.tr('Поле {} не найдено в слое населения.').format(field_name))
        transform = self._transform_for_layer(self.params.population_layer)
        totals = [0.0 for _ in polygons]
        total_population = 0.0
        features = (
            self.params.population_layer.getSelectedFeatures()
            if self.params.use_selection and self.params.population_layer.selectedFeatureCount() > 0
            else self.params.population_layer.getFeatures()
        )
        for feature in features:
            value = feature[field_idx]
            if value is None:
                continue
            try:
                population = float(value)
            except (TypeError, ValueError):
                continue
            geom = feature.geometry()
            if not geom or geom.isEmpty():
                continue
            if transform:
                try:
                    geom.transform(transform)
                except QgsCsException:
                    continue
            point = self._point_from_geometry(geom)
            if not point:
                continue
            total_population += population
            point_geom = QgsGeometry.fromPointXY(point)
            for idx, polygon in enumerate(polygons):
                if polygon and not polygon.isEmpty() and polygon.contains(point_geom):
                    totals[idx] += population
        shares = [
            (value / total_population * 100.0) if total_population > 0 else 0.0
            for value in totals
        ]
        stats = []
        for population, share in zip(totals, shares):
            stats.append({'population': population, 'share': share})
        return stats

    def _create_result_layer(
        self,
        polygons: List[Optional[QgsGeometry]],
        stats: List[Dict[str, float]],
    ) -> Optional[QgsVectorLayer]:
        crs_authid = self.params.network_layer.crs().authid()
        layer_def = f'Polygon?crs={crs_authid}' if crs_authid else 'Polygon'
        layer = QgsVectorLayer(layer_def, 'Isochrones_Zones', 'memory')
        provider = layer.dataProvider()
        fields = QgsFields()
        fields.append(QgsField('zone', QVariant.String))
        fields.append(QgsField('population', QVariant.Double))
        fields.append(QgsField('share', QVariant.Double))
        provider.addAttributes(fields)
        layer.updateFields()

        zone_names = ['outbound_only', 'return_only', 'both']
        features: List[QgsFeature] = []
        for idx, (polygon, stat) in enumerate(zip(polygons, stats)):
            if not polygon or polygon.isEmpty():
                continue
            feat = QgsFeature()
            feat.setGeometry(polygon)
            feat.setAttributes([
                zone_names[idx],
                float(stat.get('population', 0.0)),
                float(stat.get('share', 0.0)),
            ])
            features.append(feat)
        if not features:
            return None
        provider.addFeatures(features)
        layer.updateExtents()
        self._apply_default_style(layer)
        layer.setOpacity(0.3)
        return layer

    def _apply_default_style(self, layer: QgsVectorLayer):
        categories = [
            ('outbound_only', '#7FC97F', '#1B7837', self.tr('Только выезд')),
            ('return_only', '#BEAED4', '#3F007D', self.tr('Только возврат')),
            ('both', '#386CB0', '#08306B', self.tr('Обе стороны')),
        ]
        renderer_categories = []
        for value, fill_color, outline_color, label in categories:
            symbol = QgsFillSymbol.createSimple({
                'color': fill_color,
                'outline_color': outline_color,
                'outline_width': '0.5',
            })
            renderer_categories.append(QgsRendererCategory(value, symbol, label))
        renderer = QgsCategorizedSymbolRenderer('zone', renderer_categories)
        layer.setRenderer(renderer)

class MultiIntervalIsochroneProcessor:
    """Compute multiple isochrones for different time intervals."""

    SNAP_TOLERANCE = 35

class GraphBuilder:
    """Build an undirected graph from the network layer."""

    def __init__(self, params: IsochroneParameters):
        self.params = params
        self.network_layer = params.network_layer
        self.height_sampler = RasterHeightSampler(params.height_layer, self.network_layer.crs()) \
            if params.height_layer else None
        self.nodes: List[QgsPointXY] = []
        self.node_lookup: Dict[Tuple[float, float], int] = {}
        self.adjacency: Dict[int, List['GraphEdge']] = defaultdict(list)
        self.segments: List['GraphSegment'] = []

    def build(self) -> 'Graph':
        request = QgsFeatureRequest()
        for feature in self.network_layer.getFeatures(request):
            geom = feature.geometry()
            if not geom or geom.isEmpty():
                continue
            for line in self._extract_lines(geom):
                self._add_line(line)
        return Graph(self.nodes, self.adjacency, self.segments)

    def _extract_lines(self, geom: QgsGeometry) -> List[List[QgsPointXY]]:
        if geom.isMultipart():
            return [list(line) for line in geom.asMultiPolyline() if len(line) >= 2]
        line = geom.asPolyline()
        return [line] if len(line) >= 2 else []

    def _add_line(self, line: List[QgsPointXY]):
        if len(line) < 2:
            return
        for start, end in zip(line[:-1], line[1:]):
            self._add_segment(QgsPointXY(start), QgsPointXY(end))

    def _add_segment(self, start_point: QgsPointXY, end_point: QgsPointXY):
        length = start_point.distance(end_point)
        if length <= 0:
            return
        start_id = self._node_id(start_point)
        end_id = self._node_id(end_point)
        height_penalty = self._height_penalty(start_point, end_point)
        penalty = height_penalty + self.params.manual_penalty
        cost_per_meter = (length + penalty) / length if length > 0 else 1.0
        geom_forward = QgsGeometry.fromPolylineXY([start_point, end_point])
        geom_backward = QgsGeometry.fromPolylineXY([end_point, start_point])
        segment = GraphSegment(
            start=start_id,
            end=end_id,
            geom_forward=geom_forward,
            geom_backward=geom_backward,
            length=length,
            cost_per_meter=cost_per_meter,
        )
        self.segments.append(segment)
        self.adjacency[start_id].append(GraphEdge(target=end_id, segment=segment))
        self.adjacency[end_id].append(GraphEdge(target=start_id, segment=segment))

    def _node_id(self, point: QgsPointXY) -> int:
        key = (round(point.x(), 3), round(point.y(), 3))
        node_id = self.node_lookup.get(key)
        if node_id is None:
            node_id = len(self.nodes)
            self.nodes.append(point)
            self.node_lookup[key] = node_id
        return node_id

    def _height_penalty(self, start_point: QgsPointXY, end_point: QgsPointXY) -> float:
        if not self.height_sampler:
            return 0.0
        h1 = self.height_sampler.sample(start_point)
        h2 = self.height_sampler.sample(end_point)
        if h1 is None or h2 is None:
            return 0.0
        diff = abs(h2 - h1)
        if diff <= 0:
            return 0.0
        ratio = diff / self.params.height_step
        if not self.params.continuous_penalty:
            ratio = math.floor(ratio)
        return ratio * self.params.height_penalty


class Graph:
    """Undirected graph ready for traversal."""

    def __init__(
        self,
        nodes: List[QgsPointXY],
        adjacency: Dict[int, List['GraphEdge']],
        segments: List['GraphSegment'],
    ):
        self.nodes = nodes
        self.adjacency = adjacency
        self.segments = segments
        self.index = QgsSpatialIndex()
        for idx, point in enumerate(nodes):
            feature = QgsFeature()
            feature.setId(idx)
            feature.setGeometry(QgsGeometry.fromPointXY(point))
            self.index.addFeature(feature)

    def nearest_node(self, point: QgsPointXY) -> Tuple[Optional[int], Optional[float]]:
        candidates = self.index.nearestNeighbor(point, 1)
        if not candidates:
            return None, None
        node_id = candidates[0]
        node_point = self.nodes[node_id]
        distance = math.hypot(node_point.x() - point.x(), node_point.y() - point.y())
        return node_id, distance


@dataclass
class GraphSegment:
    start: int
    end: int
    geom_forward: QgsGeometry
    geom_backward: QgsGeometry
    length: float
    cost_per_meter: float

    def total_cost(self) -> float:
        return self.length * self.cost_per_meter


@dataclass
class GraphEdge:
    target: int
    segment: GraphSegment


class RasterHeightSampler:
    """Sample raster heights to adjust penalties."""

    def __init__(self, layer: Optional[QgsRasterLayer], network_crs):
        self.layer = layer
        self.transform = None
        if layer:
            self.transform = QgsCoordinateTransform(network_crs, layer.crs(), QgsProject.instance())

    def sample(self, point: QgsPointXY) -> Optional[float]:
        if not self.layer:
            return None
        sample_point = QgsPointXY(point)
        if self.transform:
            try:
                sample_point = self.transform.transform(sample_point)
            except QgsCsException:
                return None
        result = self.layer.dataProvider().sample(sample_point, 1)
        if not result[1]:
            return None
        value = result[0]
        if value is None or (isinstance(value, float) and math.isnan(value)):
            return None
        try:
            return float(value)
        except (TypeError, ValueError):
            return None

class MultiIntervalIsochroneProcessor:
    """Compute multiple isochrones for different time intervals."""

    SNAP_TOLERANCE = 35.0

    def __init__(self, iface, params):
        self.iface = iface
        self.params = params
        self.project = QgsProject.instance()
        self.network_crs = params.network_layer.crs()
        self._transform_cache = {}
        self.graph = None
        self._tolerance_warning_shown = False

    def tr(self, text):
        return QCoreApplication.translate('Isochrones', text)

    def run(self):
        builder = GraphBuilderTask2(self.params)
        self.graph = builder.build()

        start_point = self._get_starting_point()
        if not start_point:
            raise IsochroneError(self.tr('Не удалось определить точку начала.'))

        start_node, distance = self.graph.nearest_node(start_point)
        if start_node is None:
            raise IsochroneError(self.tr('Не удалось найти ближайший узел графа.'))

        zones = []
        for interval in sorted(self.params.time_intervals):
            limit_meters = (interval * self.params.speed_kmh * 1000) / 60
            
            distances = self._dijkstra([start_node], limit_meters)
            zone = self._build_zone_for_interval(distances, limit_meters)
            
            if zone and not zone.isEmpty():
                population = self._calculate_population(zone)
                area_ha = zone.area() / 10000
                
                zones.append({
                    'interval': interval,
                    'geometry': zone,
                    'population': population,
                    'area_ha': area_ha
                })

        if not zones:
            raise IsochroneError(self.tr('Не удалось построить ни одну зону.'))

        layer = self._create_multi_zone_layer(zones)
        summary = self._build_summary(zones)
        
        if layer:
            layer.setAbstract(summary)
            layer.setCustomProperty('Isochrones/summary', summary)
        
        QgsMessageLog.logMessage(summary, 'Isochrones', Qgis.Info)
        
        if self.params.add_to_project and layer:
            QgsProject.instance().addMapLayer(layer)
        
        return summary

    def _get_starting_point(self):
        if hasattr(self.params, 'start_point_id') and self.params.start_point_id:
            layer = self.params.stop_layer
            field_name = self.params.stop_id_field
            field_idx = layer.fields().indexOf(field_name)
            
            if field_idx == -1:
                raise IsochroneError(self.tr('Поле {} не найдено.').format(field_name))
            
            transform = self._transform_for_layer(layer)
            
            for feature in layer.getFeatures():
                if str(feature[field_idx]) == self.params.start_point_id:
                    geom = feature.geometry()
                    if not geom or geom.isEmpty():
                        continue
                    
                    if transform:
                        geom.transform(transform)
                    
                    if geom.type() == QgsWkbTypes.PointGeometry:
                        if geom.isMultipart():
                            points = geom.asMultiPoint()
                            return QgsPointXY(points[0]) if points else None
                        return QgsPointXY(geom.asPoint())
            
            raise IsochroneError(self.tr('Точка с ID {} не найдена.').format(self.params.start_point_id))
        
        return None

    def _transform_for_layer(self, layer):
        if layer.crs() == self.network_crs:
            return None
        key = layer.id()
        if key not in self._transform_cache:
            self._transform_cache[key] = QgsCoordinateTransform(layer.crs(), self.network_crs, self.project)
        return self._transform_cache[key]

    def _dijkstra(self, source_nodes, limit):
        dist = {}
        queue = []
        
        for node in source_nodes:
            dist[node] = 0.0
            heapq.heappush(queue, (0.0, node))
        
        while queue:
            cost, node = heapq.heappop(queue)
            if cost > limit:
                continue
            if cost > dist.get(node, math.inf):
                continue
            
            for edge in self.graph.adjacency.get(node, []):
                next_cost = cost + edge.segment.total_cost()
                if next_cost > limit:
                    continue
                if next_cost + 1e-6 < dist.get(edge.target, math.inf):
                    dist[edge.target] = next_cost
                    heapq.heappush(queue, (next_cost, edge.target))
        
        return dist

    def _build_zone_for_interval(self, distances, limit):
        if not distances:
            return None
        
        line_geoms = []
        for segment in self.graph.segments:
            if segment.start in distances:
                geom = self._segment_coverage(segment, True, distances[segment.start], limit)
                if geom:
                    line_geoms.append(geom)
            if segment.end in distances:
                geom = self._segment_coverage(segment, False, distances[segment.end], limit)
                if geom:
                    line_geoms.append(geom)

        corridor = self.params.corridor_width
        line_buffers = [
            geom.buffer(corridor, 3)
            for geom in line_geoms
            if geom and not geom.isEmpty()
        ]
        
        node_buffers = []
        max_radius = corridor
        
        for node_id, cost in distances.items():
            remaining = limit - cost
            if remaining <= 0:
                continue
            radius = min(max_radius, remaining)
            if radius <= 0:
                continue
            point = QgsGeometry.fromPointXY(self.graph.nodes[node_id])
            node_buffers.append(point.buffer(radius, 6))

        candidates = [geom for geom in line_buffers + node_buffers if geom and not geom.isEmpty()]
        if not candidates:
            return None
        
        zone = QgsGeometry.unaryUnion(candidates)
        if zone and zone.type() != QgsWkbTypes.PolygonGeometry:
            zone = zone.buffer(self.params.corridor_width, 4)
        
        if zone:
            zone = zone.makeValid()
            try:
                hull = zone.concaveHull(0.4, False)
                if hull and not hull.isEmpty():
                    zone = hull.makeValid()
            except AttributeError:
                pass
        
        return zone

    def _segment_coverage(self, segment, forward, start_cost, limit):
        remaining = limit - start_cost
        if remaining <= 0 or segment.cost_per_meter <= 0:
            return None
        
        max_length = min(segment.length, remaining / segment.cost_per_meter)
        if max_length <= 0:
            return None
        
        geom = segment.geom_forward if forward else segment.geom_backward
        if max_length >= segment.length - 0.01:
            return geom
        
        try:
            return geom.curveSubstring(0, max_length)
        except AttributeError:
            return geom

    def _calculate_population(self, zone):
        if not self.params.population_layer or not self.params.population_field:
            return 0.0
        
        field_name = self.params.population_field
        field_idx = self.params.population_layer.fields().indexOf(field_name)
        if field_idx == -1:
            return 0.0
        
        transform = self._transform_for_layer(self.params.population_layer)
        total_population = 0.0
        
        for feature in self.params.population_layer.getFeatures():
            value = feature[field_idx]
            if value is None:
                continue
            
            try:
                population = float(value)
            except (TypeError, ValueError):
                continue
            
            geom = feature.geometry()
            if not geom or geom.isEmpty():
                continue
            
            if transform:
                try:
                    geom.transform(transform)
                except QgsCsException:
                    continue
            
            point = self._point_from_geometry(geom)
            if not point:
                continue
            
            point_geom = QgsGeometry.fromPointXY(point)
            if zone.contains(point_geom):
                total_population += population
        
        return total_population

    def _point_from_geometry(self, geom):
        if geom.type() == QgsWkbTypes.PointGeometry:
            if geom.isMultipart():
                points = geom.asMultiPoint()
                return QgsPointXY(points[0]) if points else None
            return QgsPointXY(geom.asPoint())
        
        centroid = geom.centroid()
        if centroid and not centroid.isEmpty():
            return QgsPointXY(centroid.asPoint())
        
        return None

    def _create_multi_zone_layer(self, zones):
        crs_authid = self.params.network_layer.crs().authid()
        layer_def = f'Polygon?crs={crs_authid}' if crs_authid else 'Polygon'
        layer = QgsVectorLayer(layer_def, 'Изохроны_Интервалы', 'memory')
        
        provider = layer.dataProvider()
        fields = QgsFields()
        fields.append(QgsField('interval', QVariant.Int))
        fields.append(QgsField('population', QVariant.Double))
        fields.append(QgsField('area_ha', QVariant.Double))
        provider.addAttributes(fields)
        layer.updateFields()

        features = []
        for zone_data in zones:
            if not zone_data['geometry'] or zone_data['geometry'].isEmpty():
                continue
            
            feat = QgsFeature()
            feat.setGeometry(zone_data['geometry'])
            feat.setAttributes([
                zone_data['interval'],
                zone_data['population'],
                zone_data['area_ha']
            ])
            features.append(feat)
        
        if not features:
            return None
        
        provider.addFeatures(features)
        layer.updateExtents()
        self._apply_interval_style(layer)
        layer.setOpacity(0.4)
        
        return layer

    def _apply_interval_style(self, layer):
        intervals = set()
        for feat in layer.getFeatures():
            intervals.add(feat['interval'])
        
        intervals = sorted(intervals)
        colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628']
        
        categories = []
        for i, interval in enumerate(intervals):
            color = colors[i % len(colors)]
            symbol = QgsFillSymbol.createSimple({
                'color': color,
                'outline_color': '#000000',
                'outline_width': '0.5',
            })
            categories.append(QgsRendererCategory(interval, symbol, f'{interval} мин'))
        
        renderer = QgsCategorizedSymbolRenderer('interval', categories)
        layer.setRenderer(renderer)

    def _build_summary(self, zones):
        parts = []
        for zone in zones:
            parts.append(f"{zone['interval']} мин: {zone['population']:.0f} чел., {zone['area_ha']:.2f} га")
        return '; '.join(parts)

class GraphBuilderTask2:
    """Build graph for task 2 with speed support."""

    def __init__(self, params):
        self.params = params
        self.network_layer = params.network_layer
        self.height_sampler = RasterHeightSampler(params.height_layer, self.network_layer.crs()) \
            if params.height_layer else None
        self.nodes = []
        self.node_lookup = {}
        self.adjacency = defaultdict(list)
        self.segments = []

    def build(self):
        request = QgsFeatureRequest()
        for feature in self.network_layer.getFeatures(request):
            geom = feature.geometry()
            if not geom or geom.isEmpty():
                continue
            for line in self._extract_lines(geom):
                self._add_line(line, feature)
        return Graph(self.nodes, self.adjacency, self.segments)

    def _extract_lines(self, geom):
        if geom.isMultipart():
            return [list(line) for line in geom.asMultiPolyline() if len(line) >= 2]
        line = geom.asPolyline()
        return [line] if len(line) >= 2 else []

    def _add_line(self, line, feature):
        if len(line) < 2:
            return
        for start, end in zip(line[:-1], line[1:]):
            self._add_segment(QgsPointXY(start), QgsPointXY(end), feature)

    def _add_segment(self, start_point, end_point, feature):
        length = start_point.distance(end_point)
        if length <= 0:
            return
        
        start_id = self._node_id(start_point)
        end_id = self._node_id(end_point)
        
        base_speed = self.params.speed_kmh
        
        if self.params.use_uds_speeds and hasattr(self.params, 'uds_speed_field') and self.params.uds_speed_field:
            speed_field_idx = feature.fields().indexOf(self.params.uds_speed_field)
            if speed_field_idx >= 0:
                feature_speed = feature[self.params.uds_speed_field]
                if feature_speed and feature_speed > 0:
                    base_speed = float(feature_speed)
        
        height_penalty = self._height_penalty(start_point, end_point)
        penalty = height_penalty + self.params.manual_penalty
        
        cost_per_meter = (length + penalty) / length if length > 0 else 1.0
        
        geom_forward = QgsGeometry.fromPolylineXY([start_point, end_point])
        geom_backward = QgsGeometry.fromPolylineXY([end_point, start_point])
        
        segment = GraphSegment(
            start=start_id,
            end=end_id,
            geom_forward=geom_forward,
            geom_backward=geom_backward,
            length=length,
            cost_per_meter=cost_per_meter,
        )
        
        self.segments.append(segment)
        self.adjacency[start_id].append(GraphEdge(target=end_id, segment=segment))
        self.adjacency[end_id].append(GraphEdge(target=start_id, segment=segment))

    def _node_id(self, point):
        key = (round(point.x(), 3), round(point.y(), 3))
        node_id = self.node_lookup.get(key)
        if node_id is None:
            node_id = len(self.nodes)
            self.nodes.append(point)
            self.node_lookup[key] = node_id
        return node_id

    def _height_penalty(self, start_point, end_point):
        if not self.height_sampler:
            return 0.0
        
        h1 = self.height_sampler.sample(start_point)
        h2 = self.height_sampler.sample(end_point)
        
        if h1 is None or h2 is None:
            return 0.0
        
        diff = abs(h2 - h1)
        if diff <= 0:
            return 0.0
        
        ratio = diff / self.params.height_step
        if not self.params.continuous_penalty:
            ratio = math.floor(ratio)
        
        return ratio * self.params.height_penalty